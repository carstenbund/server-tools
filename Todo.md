Below is a **coherent blueprint** for a *unified Linux server toolkit* built around:

* **A single CLI entry point**
* **An index of tools**
* **A config system**
* **Remote/AI evaluation hooks**
* **Extremely broad Python compatibility (2.6–3.6)**
* **SSH-friendly proto-API behavior**

The approach is intentionally minimalistic, modular, and robust on old servers.

---

# Overall Architecture

We build a small system called:

**steward/** (or any name you prefer)

```
steward/
    steward.py        # single CLI entry point
    tools/
        __init__.py
        users.py
        samba.py
        nfs.py
        fs.py
        processes.py
        logs.py
        network.py
        security.py
    config/
        steward.conf   # simple INI or JSON
    core/
        loader.py      # loads tool index dynamically
        dispatcher.py  # calls functions by name
        reporter.py    # formats output
        remote_eval.py # optional AI/remote hook
```

Everything is built so that **steward.py** acts as:

* **CLI command**
* **SSFriendly proto-API**
* **Module dispatcher**
* **Automation engine**

---

# 1. Tool Index

### `tools/__init__.py`

```python
TOOLS = {
    "users": "tools.users",
    "samba": "tools.samba",
    "nfs": "tools.nfs",
    "fs": "tools.fs",
    "proc": "tools.processes",
    "logs": "tools.logs",
    "net": "tools.network",
    "sec": "tools.security"
}
```

Each module provides **simple self-describing functions**, e.g.

```
def list_users()
def create_user(name)
def check_samba()
def list_mounts()
def free_space(path="/")
def find_zombies()
...
```

The dispatcher introspects modules via `dir()` and exposes only functions starting with allowed prefixes (like `list_`, `check_`, `scan_`, `get_`, etc.)

---

# 2. Config System

Compatibility requirements rule out tomllib, yaml, pydantic etc.
We stick to **ConfigParser** for Python 2.6–3.6.

### Example INI:

```
[general]
log_file=/var/log/steward.log
remote_eval_url=http://your-ai-endpoint/eval

[alerts]
disk_threshold=10
zombie_threshold=5
```

### Loading config

`core/loader.py`:

```python
import ConfigParser, os

def load_config():
    path = os.path.join(os.path.dirname(__file__), "..", "config", "steward.conf")
    parser = ConfigParser.SafeConfigParser()
    parser.read(path)
    return parser
```

---

# 3. CLI Interface

### The CLI workflow:

```
$ steward list tools
$ steward run users.list_users
$ steward run fs.free_space /
$ steward run net.ping_host google.com
$ steward status
$ steward ai-eval system
```

### Design goals:

* **SSH-friendly** (no curses, no fancy formatting required)
* **Parsable output** for automation
* **Help output** autogenerated from functions

---

### Core CLI (steward.py)

```python
#!/usr/bin/env python
import sys
from core.dispatcher import call_tool, list_all_tools
from core.loader import load_config
from core.remote_eval import remote_eval

def main():
    if len(sys.argv) < 2:
        print("Usage: steward <command> [args]")
        print("Commands: list tools | run <tool.function> [...args] | status | ai-eval <target>")
        sys.exit(1)

    cmd = sys.argv[1]

    if cmd == "list":
        print("\n".join(list_all_tools()))
        sys.exit(0)

    if cmd == "run":
        func = sys.argv[2]
        args = sys.argv[3:]
        result = call_tool(func, args)
        print(result)
        sys.exit(0)

    if cmd == "status":
        # could run a set of default metrics
        print(call_tool("fs.free_space", ["/"]))
        print(call_tool("proc.list_zombies", []))
        sys.exit(0)

    if cmd == "ai-eval":
        target = sys.argv[2]
        cfg = load_config()
        print(remote_eval(target, cfg))
        sys.exit(0)

if __name__ == "__main__":
    main()
```

---

# 4. Dispatcher

### `core/dispatcher.py`

```python
import importlib

from tools import TOOLS

def list_all_tools():
    out = []
    for name, module_path in TOOLS.items():
        module = importlib.import_module(module_path)
        for attr in dir(module):
            if attr.startswith(("list_", "check_", "scan_", "get_", "find_", "free_", "create_", "restart_", "ping_")):
                out.append(name + "." + attr)
    return out


def call_tool(path, args):
    # path looks like: "fs.free_space"
    tool, func = path.split(".", 1)
    module = importlib.import_module(TOOLS[tool])
    fn = getattr(module, func)

    # Convert args to positional Python arguments
    return fn(*args)
```

This keeps the whole toolkit **pure-function-based**.

---

# 5. Example Tool Module: processes

### `tools/processes.py`

```python
import os

def find_zombies():
    zombies = []
    for pid in os.listdir("/proc"):
        if pid.isdigit():
            try:
                data = open("/proc/%s/status" % pid).read()
                if "State:\tZ" in data:
                    zombies.append(int(pid))
            except:
                pass
    return zombies

def list_processes():
    return os.listdir("/proc")
```

Everything stays intentionally primitive and stable.

---

# 6. Built-in Status Command

The unified tool can expose a **default health overview**:

* free space
* loadavg
* zombie count
* failed services
* network ping to default targets

### Example default status snapshot:

```python
def system_status():
    return {
        "disk_root_free": fs.free_space("/"),
        "zombies": processes.find_zombies(),
        "loadavg": open('/proc/loadavg').read(),
        "nfs_mounts": nfs.list_nfs_mounts(),
    }
```

---

# 7. Remote / AI Evaluation Hook

The "proto API" part includes the ability to send:

* a bundle of metrics
* a system summary
* the output of any function

to a remote endpoint that can be an **AI system**, or a central server.

### `core/remote_eval.py`

```python
import urllib2
import json
from system_summary import get_snapshot

def remote_eval(target, config):
    url = config.get("general", "remote_eval_url")
    data = {
        "target": target,
        "snapshot": get_snapshot(),
    }
    req = urllib2.Request(url, json.dumps(data), {'Content-Type': 'application/json'})
    try:
        res = urllib2.urlopen(req, timeout=5).read()
        return res
    except Exception as e:
        return "REMOTE ERROR: %s" % e
```

### System summary example:

```python
def get_snapshot():
    import subprocess, os
    return {
        "hostname": open('/etc/hostname').read().strip(),
        "load": open('/proc/loadavg').read(),
        "disk": subprocess.check_output(["df", "-h"]),
        "zombies": call_tool("proc.find_zombies", []),
    }
```

This allows:

* **central agent**
* **automated evaluation**
* **AI orchestration**

while keeping the server side passive.

---

# 8. Proto API Behavior (SSH-Friendly)

Any output is:

1. Plain text by default
2. JSON on request:

   ```
   steward run fs.free_space / --json
   ```

This makes remote parsing trivial.

---

# 9. Hardening & Compatibility Guarantees

* No third-party libraries
* No Python 3-only syntax
* No assumptions about systemd
* All subprocess calls fallback to legacy binary names
* Optional `--dry-run` mode
* Single-file deployment (`zipapp` possible)

---

# 10. Suggested Next Steps

If you want, I can generate:

### A. **Complete ready-to-run skeleton**

With all modules stubbed and working.

### B. **A fully populated default tool library**

Users, NFS, Samba, FS, Processes, Logs, Network, Security, Backup, Cron, Services, etc.

### C. **A single-file deployment**

Everything merged into one file for old servers.

### D. **An optional remote AI evaluator server**

Python Flask or FastAPI (for your orchestrator) that receives snapshots.

### E. **An internal command registry generator**

Autodetects functions, builds CLI help automatically.

## suggested implementation:

Below is a structured list of **common Linux server tasks** together with **Python-2.6–3.6–compatible script designs** (using only standard library modules unless noted).
Each section includes:

* **Use case / goal**
* **Approach** using system defaults
* **Minimal Python script pattern** (pseudo-real code)
* **Optional improvements / alternatives**

I keep everything compatible with 2.6 by avoiding f-strings, subprocess conveniences, pathlib, etc.

---

# 1. User Management

### Goal

List users, create/delete users, reset passwords, lock/unlock accounts.

### Approach

Use `/etc/passwd`, `/etc/shadow`, and `subprocess` to call `useradd`, `usermod`, `passwd`.

### Script Pattern

```python
#!/usr/bin/env python
import subprocess

def list_users():
    users = []
    for line in open('/etc/passwd'):
        name = line.split(':', 1)[0]
        users.append(name)
    return users

def create_user(name):
    subprocess.call(["useradd", name])

def disable_user(name):
    subprocess.call(["usermod", "-L", name])

def reset_password(name, password):
    p = subprocess.Popen(["passwd", "--stdin", name], stdin=subprocess.PIPE)
    p.communicate(password + "\n")

if __name__ == "__main__":
    print(list_users())
```

### Notes

* `passwd --stdin` works on RHEL-based systems. Debian requires using `chpasswd`.

---

# 2. Samba Share Monitoring

### Goal

Check running SMB, list shares, restart service, validate config.

### Approach

Call `testparm`, `smbstatus`, systemctl/init.d.

### Script Pattern

```python
import subprocess

def smb_status():
    return subprocess.check_output(["smbstatus"])

def check_samba_config():
    try:
        subprocess.check_call(["testparm", "-s"])
        return True
    except:
        return False

def restart_samba():
    subprocess.call(["systemctl", "restart", "smb"])  # OR "smbd"
```

---

# 3. NFS Status / Exports

### Goal

List exported directories, currently mounted NFS, server status.

### Approach

Use `/etc/exports`, `showmount`, `systemctl`, `/proc/mounts`.

### Script Pattern

```python
import subprocess

def nfs_exports():
    return open('/etc/exports').read()

def nfs_clients():
    return subprocess.check_output(["showmount", "-a"])

def list_nfs_mounts():
    mounts = []
    for line in open('/proc/mounts'):
        if line.startswith('nfs'):
            mounts.append(line.strip())
    return mounts
```

---

# 4. Mounted Filesystems & Disk Usage

### Goal

Monitor free space, detect failed mounts, log levels.

### Approach

Use `/proc/mounts`, `df -h`, `os.statvfs`.

### Script Pattern

```python
import os

def fs_usage(path):
    st = os.statvfs(path)
    total = st.f_frsize * st.f_blocks
    free = st.f_frsize * st.f_bfree
    used = total - free
    return total, used, free
```

---

# 5. Process Monitoring & Zombie Detection

### Goal

Find zombies, kill runaway tasks, check uptime, resource usage.

### Approach

Detect process state via `ps`, `/proc/<pid>/status`.

### Zombie Detection Script

```python
import os

def list_zombies():
    zombies = []
    for pid in os.listdir("/proc"):
        if not pid.isdigit():
            continue
        try:
            status = open("/proc/%s/status" % pid).read()
        except:
            continue
        if "\nState:\tZ" in status:
            zombies.append(int(pid))
    return zombies
```

---

# 6. Log Rotation & Old File Archiving

### Goal

Move old logs (> X days) to archive or delete.

### Approach

Use `os.walk`, file mtime, `tarfile`.

### Script Pattern

```python
import os, time, tarfile

def archive_old_files(path, days, tarfile_path):
    cutoff = time.time() - days * 86400
    tar = tarfile.open(tarfile_path, "w:gz")
    for root, dirs, files in os.walk(path):
        for f in files:
            fp = os.path.join(root, f)
            if os.path.getmtime(fp) < cutoff:
                tar.add(fp)
    tar.close()
```

---

# 7. Disk Space Monitoring

### Goal

Automatically alert or clean when space < threshold.

### Approach

`shutil.disk_usage` is 3.3+, so use `statvfs` (works in 2.6).

### Script Pattern

```python
import os

def low_space_alert(path, percent):
    st = os.statvfs(path)
    free = float(st.f_bavail) / float(st.f_blocks) * 100
    if free < percent:
        return True
    return False
```

---

# 8. Service Status & Restart Handling

### Goal

Check if essential services are up: sshd, nginx, postgres…

### Approach

Call `systemctl is-active`, fall back to init.d.

```python
import subprocess

def service_active(name):
    try:
        out = subprocess.check_output(["systemctl", "is-active", name])
        return out.strip() == 'active'
    except:
        return False

def service_restart(name):
    subprocess.call(["systemctl", "restart", name])
```

---

# 9. Backup Automation

### Goal

Run rsync jobs, snapshot directories, log results.

### Script Pattern

```python
import subprocess, time

def backup(src, dest):
    cmd = ["rsync", "-a", "--delete", src, dest]
    log = "/var/log/backup-%s.log" % time.strftime("%Y%m%d")
    with open(log, "a") as f:
        subprocess.call(cmd, stdout=f, stderr=f)
```

---

# 10. System Health Summary (Quick Audit Script)

### Goal

Single script to show essential server status for troubleshooting.

### Script Pattern

```python
import subprocess, socket, os, time

def system_summary():
    print("Hostname:", socket.gethostname())
    print("Uptime:", open("/proc/uptime").read().split()[0])
    print("Disk:")
    print(subprocess.check_output(["df", "-h"]))
    print("Top CPU:")
    print(subprocess.check_output("ps aux --sort=-%cpu | head", shell=True))
    print("Zombies:", list_zombies())
```

---

# 11. Network Diagnostics

### Goal

Ping gateways, check DNS, verify interface state.

### Script Pattern

```python
import subprocess

def ping_host(host):
    return subprocess.call(["ping", "-c", "2", host]) == 0

def dns_lookup(domain):
    return subprocess.check_output(["host", domain])
```

---

# 12. Security & Patch Level Checks

### Goal

List update candidates, check kernel version, outdated services.

### Script Pattern

(Debian example)

```python
import subprocess

def list_updates():
    return subprocess.check_output(["apt-get", "-s", "upgrade"])
```

---

# 13. Cron Job Management

### Goal

Create, list, validate cron tasks automatically.

### Script Pattern

```python
import subprocess, tempfile

def add_cronjob(line):
    old = subprocess.check_output(["crontab", "-l"])
    new = old + "\n" + line + "\n"
    p = subprocess.Popen(["crontab", "-"], stdin=subprocess.PIPE)
    p.communicate(new)
```

---

# 14. System Configuration Auditing

### Goal

Compare configs with master copies, perform checksum verification.

### Script Pattern

```python
import hashlib

def file_checksum(path):
    h = hashlib.md5()
    f = open(path, "rb")
    while 1:
        chunk = f.read(8192)
        if not chunk:
            break
        h.update(chunk)
    f.close()
    return h.hexdigest()
```

---

# 15. Hardware/Resource Probing

### Goal

Detect CPU, RAM, load average, temperature (if available).

### Script Pattern

```python
import os

def meminfo():
    return open('/proc/meminfo').read()

def loadavg():
    return open('/proc/loadavg').read()

def cpuinfo():
    return open('/proc/cpuinfo').read()
```

---

# 16. Email Alerts for Any Script

### Goal

Mail notifications via local MTA.

### Script Pattern

```python
import subprocess

def send_mail(to, subject, body):
    msg = "Subject: %s\n\n%s" % (subject, body)
    p = subprocess.Popen(["/usr/sbin/sendmail", to], stdin=subprocess.PIPE)
    p.communicate(msg)
```

---

# 17. Configuration Deployment / Small CM System

### Goal

Push config files and restart services.

### Script Pattern

```python
import shutil, subprocess

def deploy_config(src, dest, service):
    shutil.copy(src, dest)
    subprocess.call(["systemctl", "restart", service])
```

---

# 18. Log Scanner (Auth, SSH, Syslog)

### Goal

Detect suspicious events (SSH brute force, sudo errors).

### Script Pattern

```python
import re

def scan_auth_log(path="/var/log/auth.log"):
    alerts = []
    failed = re.compile(r"Failed password.*from (\S+)")
    for line in open(path):
        m = failed.search(line)
        if m:
            alerts.append(m.group(1))
    return alerts
```
